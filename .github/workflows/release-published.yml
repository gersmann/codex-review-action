name: Release Published

on:
  release:
    types: [published, edited]

permissions:
  contents: write

jobs:
  retag:
    name: Point v1/latest to published release
    runs-on: ubuntu-latest
    steps:
      - name: Configure git identity
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
      - name: Update v1 and latest tags
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const originalTag = context.payload.release.tag_name;
            let effectiveTag = originalTag;

            async function resolveCommitSha(tag) {
              const ref = await github.rest.git.getRef({ owner, repo, ref: `tags/${tag}` });
              let sha = ref.data.object.sha;
              if (ref.data.object.type === 'tag') {
                const tagObj = await github.rest.git.getTag({ owner, repo, tag_sha: sha });
                sha = tagObj.data.object.sha; // commit SHA
              }
              return sha;
            }

            // Resolve the commit SHA for whichever tag we end up using
            let targetSha = await resolveCommitSha(originalTag);

            // If the published release is not semver-like (e.g., 'next'), promote it to v1.N
            if (!/^v(\d+)(?:[.-].*)?$/.test(originalTag || '')) {
              // Find the highest existing v1.N tag
              let page = 1;
              let maxN = -1;
              while (true) {
                const { data: tags } = await github.rest.repos.listTags({ owner, repo, per_page: 100, page });
                if (!tags.length) break;
                for (const t of tags) {
                  const m = /^v1\.(\d+)(?:[.-].*)?$/.exec(t.name);
                  if (m) {
                    const n = parseInt(m[1], 10);
                    if (!Number.isNaN(n)) maxN = Math.max(maxN, n);
                  }
                }
                if (tags.length < 100) break;
                page += 1;
              }
              let nextN = maxN + 1; // starts at 0 if none exist
              let newTag;
              // Try creating v1.N; if it exists, bump N until it works (up to 20 tries)
              for (let i = 0; i < 20; i++) {
                newTag = `v1.${nextN}`;
                try {
                  await github.rest.git.createRef({ owner, repo, ref: `refs/tags/${newTag}`, sha: targetSha });
                  core.info(`Created refs/tags/${newTag} -> ${targetSha}`);
                  break;
                } catch (e) {
                  if (e.status === 422) {
                    nextN += 1;
                    continue;
                  }
                  core.setFailed(`Failed creating tag ${newTag}: ${e.message}`);
                  return;
                }
              }
              if (!newTag) {
                core.setFailed('Exhausted attempts to create a unique v1.N tag.');
                return;
              }

              // Update the published release to the versioned tag and make it latest
              try {
                await github.rest.repos.updateRelease({
                  owner,
                  repo,
                  release_id: context.payload.release.id,
                  tag_name: newTag,
                  name: newTag,
                  draft: false,
                  make_latest: 'true',
                });
                core.info(`Promoted release to ${newTag}`);
              } catch (e) {
                core.setFailed(`Failed to update release to ${newTag}: ${e.message}`);
                return;
              }

              // Try to delete the placeholder tag (e.g., 'next') if it exists
              try {
                await github.rest.git.deleteRef({ owner, repo, ref: `tags/${originalTag}` });
                core.info(`Deleted refs/tags/${originalTag}`);
              } catch (e) {
                core.info(`Could not delete refs/tags/${originalTag}: ${e.message}`);
              }

              effectiveTag = newTag;
            }

            // If the effective tag has major v1, (re)point v1 and latest to this commit
            const m = /^v(\d+)(?:[.-].*)?$/.exec(effectiveTag || '');
            if (!m) {
              core.info(`Effective tag ${effectiveTag} is not semver-like; skipping v1/latest retag.`);
              return;
            }
            const major = parseInt(m[1], 10);
            if (major !== 1) {
              core.info(`Major version ${major} != 1; skipping retag of v1/latest.`);
              return;
            }

            async function upsertTag(tag) {
              const shortRef = `tags/${tag}`;
              const fullRef = `refs/${shortRef}`;
              try {
                await github.rest.git.updateRef({ owner, repo, ref: shortRef, sha: targetSha, force: true });
                core.info(`Updated ${fullRef} -> ${targetSha}`);
              } catch (err) {
                if (err.status === 422) {
                  await github.rest.git.createRef({ owner, repo, ref: fullRef, sha: targetSha });
                  core.info(`Created ${fullRef} -> ${targetSha}`);
                } else {
                  core.setFailed(`Failed to upsert ${fullRef}: ${err.message}`);
                }
              }
            }

            await upsertTag('v1');
            await upsertTag('latest');
